pub const REFS_PER_FRAME: u8 = 7; // Number of reference frames that can be used for inter prediction
pub const TOTAL_REFS_PER_FRAME: u8 = 8; // Number of reference frame types (including intra type)
pub const BLOCK_SIZE_GROUPS: u8 = 4; // Number of contexts when decoding y_mode
pub const BLOCK_SIZES: u8 = 22; // Number of different block sizes used
pub const BLOCK_INVALID: u8 = 22; // Sentinel value to mark partition choices that are not allowed
pub const MAX_SB_SIZE: u8 = 128; // Maximum size of a superblock in luma samples
pub const MI_SIZE: u8 = 4; // Smallest size of a mode info block in luma samples
pub const MI_SIZE_LOG2: u8 = 2; // Base 2 logarithm of smallest size of a mode info block
pub const MAX_TILE_WIDTH: u16 = 4096; // Maximum width of a tile in units of luma samples
pub const MAX_TILE_AREA: u32 = 4096 * 2304; // Maximum area of a tile in units of luma samples
pub const MAX_TILE_ROWS: u8 = 64; // Maximum number of tile rows
pub const MAX_TILE_COLS: u8 = 64; // Maximum number of tile columns
pub const INTRABC_DELAY_PIXELS: u16 = 256; // Number of horizontal luma samples before intra block copy can be used
pub const INTRABC_DELAY_SB64: u8 = 4; // Number of 64 by 64 blocks before intra block copy can be used
pub const NUM_REF_FRAMES: u8 = 8; // Number of frames that can be stored for future reference
pub const IS_INTER_CONTEXTS: u8 = 4; // Number of contexts for is_inter
pub const REF_CONTEXTS: u8 = 3; // Number of contexts for single_ref, comp_ref, comp_bwdref, uni_comp_ref, uni_comp_ref_p1 and uni_comp_ref_p2
pub const MAX_SEGMENTS: u8 = 8; // Number of segments allowed in segmentation map
pub const SEGMENT_ID_CONTEXTS: u8 = 3; // Number of contexts for segment_id
pub const SEG_LVL_ALT_Q: u8 = 0; // Index for quantizer segment feature
pub const SEG_LVL_ALT_LF_Y_V: u8 = 1; // Index for vertical luma loop filter segment feature
pub const SEG_LVL_REF_FRAME: u8 = 5; // Index for reference frame segment feature
pub const SEG_LVL_SKIP: u8 = 6; // Index for skip segment feature
pub const SEG_LVL_GLOBALMV: u8 = 7; // Index for global mv feature
pub const SEG_LVL_MAX: u8 = 8; // Number of segment features
pub const PLANE_TYPES: u8 = 2; // Number of different plane types (luma or chroma)
pub const TX_SIZE_CONTEXTS: u8 = 3; // Number of contexts for transform size
pub const INTERP_FILTERS: u8 = 3; // Number of values for interp_filter
pub const INTERP_FILTER_CONTEXTS: u8 = 16; // Number of contexts for interp_filter
pub const SKIP_MODE_CONTEXTS: u8 = 3; // Number of contexts for decoding skip_mode
pub const SKIP_CONTEXTS: u8 = 3; // Number of contexts for decoding skip
pub const PARTITION_CONTEXTS: u8 = 4; // Number of contexts when decoding partition
pub const TX_SIZES: u8 = 5; // Number of square transform sizes
pub const TX_SIZES_ALL: u8 = 19; // Number of transform sizes (including non-square sizes)
pub const TX_MODES: u8 = 3; // Number of values for tx_mode
pub const DCT_DCT: u8 = 0; // Inverse transform rows with DCT and columns with DCT
pub const ADST_DCT: u8 = 1; // Inverse transform rows with DCT and columns with ADST
pub const DCT_ADST: u8 = 2; // Inverse transform rows with ADST and columns with DCT
pub const ADST_ADST: u8 = 3; // Inverse transform rows with ADST and columns with ADST
pub const FLIPADST_DCT: u8 = 4; // Inverse transform rows with DCT and columns with FLIPADST
pub const DCT_FLIPADST: u8 = 5; // Inverse transform rows with FLIPADST and columns with DCT
pub const FLIPADST_FLIPADST: u8 = 6; // Inverse transform rows with FLIPADST and columns with FLIPADST
pub const ADST_FLIPADST: u8 = 7; // Inverse transform rows with FLIPADST and columns with ADST
pub const FLIPADST_ADST: u8 = 8; // Inverse transform rows with ADST and columns with FLIPADST
pub const IDTX: u8 = 9; // Inverse transform rows with identity and columns with identity
pub const V_DCT: u8 = 10; // Inverse transform rows with identity and columns with DCT
pub const H_DCT: u8 = 11; // Inverse transform rows with DCT and columns with identity
pub const V_ADST: u8 = 12; // Inverse transform rows with identity and columns with ADST
pub const H_ADST: u8 = 13; // Inverse transform rows with ADST and columns with identity
pub const V_FLIPADST: u8 = 14; // Inverse transform rows with identity and columns with FLIPADST
pub const H_FLIPADST: u8 = 15; // Inverse transform rows with FLIPADST and columns with identity
pub const TX_TYPES: u8 = 16; // Number of inverse transform types
pub const MB_MODE_COUNT: u8 = 17; // Number of values for YMode
pub const INTRA_MODES: u8 = 13; // Number of values for y_mode
pub const UV_INTRA_MODES_CFL_NOT_ALLOWED: u8 = 13; // Number of values for uv_mode when chroma from luma is not allowed
pub const UV_INTRA_MODES_CFL_ALLOWED: u8 = 14; // Number of values for uv_mode when chroma from luma is allowed
pub const COMPOUND_MODES: u8 = 8; // Number of values for compound_mode
pub const COMPOUND_MODE_CONTEXTS: u8 = 8; // Number of contexts for compound_mode
pub const COMP_NEWMV_CTXS: u8 = 5; // Number of new mv values used when constructing context for compound_mode
pub const NEW_MV_CONTEXTS: u8 = 6; // Number of contexts for new_mv
pub const ZERO_MV_CONTEXTS: u8 = 2; // Number of contexts for zero_mv
pub const REF_MV_CONTEXTS: u8 = 6; // Number of contexts for ref_mv
pub const DRL_MODE_CONTEXTS: u8 = 3; // Number of contexts for drl_mode
pub const MV_CONTEXTS: u8 = 2; // Number of contexts for decoding motion vectors including one for intra block copy
pub const MV_INTRABC_CONTEXT: u8 = 1; // Motion vector context used for intra block copy
pub const MV_JOINTS: u8 = 4; // Number of values for mv_joint
pub const MV_CLASSES: u8 = 11; // Number of values for mv_class
pub const CLASS0_SIZE: u8 = 2; // Number of values for mv_class0_bit
pub const MV_OFFSET_BITS: u8 = 10; // Maximum number of bits for decoding motion vectors
pub const MAX_LOOP_FILTER: u8 = 63; // Maximum value used for loop filtering
pub const REF_SCALE_SHIFT: u8 = 14; // Number of bits of precision when scaling reference frames
pub const SUBPEL_BITS: u8 = 4; // Number of bits of precision when choosing an inter prediction filter kernel
pub const SUBPEL_MASK: u8 = 15; // ( 1 << SUBPEL_BITS ) - 1
pub const SCALE_SUBPEL_BITS: u8 = 10; // Number of bits of precision when computing inter prediction locations
pub const MV_BORDER: u8 = 128; // Value used when clipping motion vectors
pub const PALETTE_COLOR_CONTEXTS: u8 = 5; // Number of values for color contexts
pub const PALETTE_MAX_COLOR_CONTEXT_HASH: u8 = 8; // Number of mappings between color context hash and color context
pub const PALETTE_BLOCK_SIZE_CONTEXTS: u8 = 7; // Number of values for palette block size
pub const PALETTE_Y_MODE_CONTEXTS: u8 = 3; // Number of values for palette Y plane mode contexts
pub const PALETTE_UV_MODE_CONTEXTS: u8 = 2; // Number of values for palette U and V plane mode contexts
pub const PALETTE_SIZES: u8 = 7; // Number of values for palette_size
pub const PALETTE_COLORS: u8 = 8; // Number of values for palette_color
pub const PALETTE_NUM_NEIGHBORS: u8 = 3; // Number of neighbors considered within palette computation
pub const DELTA_Q_SMALL: u8 = 3; // Value indicating alternative encoding of quantizer index delta values
pub const DELTA_LF_SMALL: u8 = 3; // Value indicating alternative encoding of loop filter delta values
pub const QM_TOTAL_SIZE: u16 = 3344; // Number of values in the quantizer matrix
pub const MAX_ANGLE_DELTA: u8 = 3; // Maximum magnitude of AngleDeltaY and AngleDeltaUV
pub const DIRECTIONAL_MODES: u8 = 8; // Number of directional intra modes
pub const ANGLE_STEP: u8 = 3; // Number of degrees of step per unit increase in AngleDeltaY or AngleDeltaUV.
pub const TX_SET_TYPES_INTRA: u8 = 3; // Number of intra transform set types
pub const TX_SET_TYPES_INTER: u8 = 4; // Number of inter transform set types
pub const WARPEDMODEL_PREC_BITS: u8 = 16; // Internal precision of warped motion models
pub const IDENTITY: u8 = 0; // Warp model is just an identity transform
pub const TRANSLATION: u8 = 1; // Warp model is a pure translation
pub const ROTZOOM: u8 = 2; // Warp model is a rotation + symmetric zoom + translation
pub const AFFINE: u8 = 3; // Warp model is a general affine transform
pub const GM_ABS_TRANS_BITS: u8 = 12; // Number of bits encoded for translational components of global motion models, if part of a ROTZOOM or AFFINE model
pub const GM_ABS_TRANS_ONLY_BITS: u8 = 9; // Number of bits encoded for translational components of global motion models, if part of a TRANSLATION model
pub const GM_ABS_ALPHA_BITS: u8 = 12; // Number of bits encoded for non-translational components of global motion models
pub const DIV_LUT_PREC_BITS: u8 = 14; // Number of fractional bits of entries in divisor lookup table
pub const DIV_LUT_BITS: u8 = 8; // Number of fractional bits for lookup in divisor lookup table
pub const DIV_LUT_NUM: u16 = 257; // Number of entries in divisor lookup table
pub const MOTION_MODES: u8 = 3; // Number of values for motion modes
pub const SIMPLE: u8 = 0; // Use translation or global motion compensation
pub const OBMC: u8 = 1; // Use overlapped block motion compensation
pub const LOCALWARP: u8 = 2; // Use local warp motion compensation
pub const LEAST_SQUARES_SAMPLES_MAX: u8 = 8; // Largest number of samples used when computing a local warp
pub const LS_MV_MAX: u16 = 256; // Largest motion vector difference to include in local warp computation
pub const WARPEDMODEL_TRANS_CLAMP: u32 = 1 << 23; // Clamping value used for translation components of warp
pub const WARPEDMODEL_NONDIAGAFFINE_CLAMP: u32 = 1 << 13; // Clamping value used for matrix components of warp
pub const WARPEDPIXEL_PREC_SHIFTS: u8 = 1 << 6; // Number of phases used in warped filtering
pub const WARPEDDIFF_PREC_BITS: u8 = 10; // Number of extra bits of precision in warped filtering
pub const GM_ALPHA_PREC_BITS: u8 = 15; // Number of fractional bits for sending non-translational warp model coefficients
pub const GM_TRANS_PREC_BITS: u8 = 6; // Number of fractional bits for sending translational warp model coefficients
pub const GM_TRANS_ONLY_PREC_BITS: u8 = 3; // Number of fractional bits used for pure translational warps
pub const INTERINTRA_MODES: u8 = 4; // Number of inter intra modes
pub const MASK_MASTER_SIZE: u8 = 64; // Size of MasterMask array
pub const SEGMENT_ID_PREDICTED_CONTEXTS: u8 = 3; // Number of contexts for segment_id_predicted
pub const FWD_REFS: u8 = 4; // Number of syntax elements for forward reference frames
pub const BWD_REFS: u8 = 3; // Number of syntax elements for backward reference frames
pub const SINGLE_REFS: u8 = 7; // Number of syntax elements for single reference frames
pub const UNIDIR_COMP_REFS: u8 = 4; // Number of syntax elements for unidirectional compound reference frames
pub const COMPOUND_TYPES: u8 = 2; // Number of values for compound_type
pub const CFL_JOINT_SIGNS: u8 = 8; // Number of values for cfl_alpha_signs
pub const CFL_ALPHABET_SIZE: u8 = 16; // Number of values for cfl_alpha_u and cfl_alpha_v
pub const COMP_INTER_CONTEXTS: u8 = 5; // Number of contexts for comp_mode
pub const COMP_REF_TYPE_CONTEXTS: u8 = 5; // Number of contexts for comp_ref_type
pub const CFL_ALPHA_CONTEXTS: u8 = 6; // Number of contexts for cfl_alpha_u and cfl_alpha_v
pub const INTRA_MODE_CONTEXTS: u8 = 5; // Number of each of left and above contexts for intra_frame_y_mode
pub const COMP_GROUP_IDX_CONTEXTS: u8 = 6; // Number of contexts for comp_group_idx
pub const COMPOUND_IDX_CONTEXTS: u8 = 6; // Number of contexts for compound_idx
pub const INTRA_EDGE_KERNELS: u8 = 3; // Number of filter kernels for the intra edge filter
pub const INTRA_EDGE_TAPS: u8 = 5; // Number of kernel taps for the intra edge filter
pub const FRAME_LF_COUNT: u8 = 4; // Number of loop filter strength values
pub const MAX_VARTX_DEPTH: u8 = 2; // Maximum depth for variable transform trees
pub const TXFM_PARTITION_CONTEXTS: u8 = 21; // Number of contexts for txfm_split
pub const REF_CAT_LEVEL: u16 = 640; // Bonus weight for close motion vectors
pub const MAX_REF_MV_STACK_SIZE: u8 = 8; // Maximum number of motion vectors in the stack
pub const MFMV_STACK_SIZE: u8 = 3; // Stack size for motion field motion vectors
pub const MAX_TX_DEPTH: u8 = 2; // Maximum times the transform can be split
pub const WEDGE_TYPES: u8 = 16; // Number of directions for the wedge mask process
pub const FILTER_BITS: u8 = 7; // Number of bits used in Wiener filter coefficients
pub const WIENER_COEFFS: u8 = 3; // Number of Wiener filter coefficients to read
pub const SGRPROJ_PARAMS_BITS: u8 = 4; // Number of bits needed to specify self guided filter set
pub const SGRPROJ_PRJ_SUBEXP_K: u8 = 4; // Controls how self guided deltas are read
pub const SGRPROJ_PRJ_BITS: u8 = 7; // Precision bits during self guided restoration
pub const SGRPROJ_RST_BITS: u8 = 4; // Restoration precision bits generated higher than source before projection
pub const SGRPROJ_MTABLE_BITS: u8 = 20; // Precision of mtable division table
pub const SGRPROJ_RECIP_BITS: u8 = 12; // Precision of division by n table
pub const SGRPROJ_SGR_BITS: u8 = 8; // Internal precision bits for core selfguided_restoration
pub const EC_PROB_SHIFT: u8 = 6; // Number of bits to reduce CDF precision during arithmetic coding
pub const EC_MIN_PROB: u8 = 4; // Minimum probability assigned to each symbol during arithmetic coding
pub const SELECT_SCREEN_CONTENT_TOOLS: u8 = 2; // Value that indicates the allow_screen_content_tools syntax element is coded
pub const SELECT_INTEGER_MV: u8 = 2; // Value that indicates the force_integer_mv syntax element is coded
pub const RESTORATION_TILESIZE_MAX: u16 = 256; // Maximum size of a loop restoration tile
pub const MAX_FRAME_DISTANCE: u8 = 31; // Maximum distance when computing weighted prediction
pub const MAX_OFFSET_WIDTH: u8 = 8; // Maximum horizontal offset of a projected motion vector
pub const MAX_OFFSET_HEIGHT: u8 = 0; // Maximum vertical offset of a projected motion vector
pub const WARP_PARAM_REDUCE_BITS: u8 = 6; // Rounding bitwidth for the parameters to the shear process
pub const NUM_BASE_LEVELS: u8 = 2; // Number of quantizer base levels
pub const COEFF_BASE_RANGE: u8 = 12; // The quantizer range above NUM_BASE_LEVELS above which the Exp-Golomb coding process is activated
pub const BR_CDF_SIZE: u8 = 4; // Number of values for coeff_br
pub const SIG_COEF_CONTEXTS_EOB: u8 = 4; // Number of contexts for coeff_base_eob
pub const SIG_COEF_CONTEXTS_2D: u8 = 26; // Context offset for coeff_base for horizontal-only or vertical-only transforms.
pub const SIG_COEF_CONTEXTS: u8 = 42; // Number of contexts for coeff_base
pub const SIG_REF_DIFF_OFFSET_NUM: u8 = 5; // Maximum number of context samples to be used in determining the context index for coeff_base and coeff_base_eob.
pub const SUPERRES_NUM: u8 = 8; // Numerator for upscaling ratio
pub const SUPERRES_DENOM_MIN: u8 = 9; // Smallest denominator for upscaling ratio
pub const SUPERRES_DENOM_BITS: u8 = 3; // Number of bits sent to specify denominator of upscaling ratio
pub const SUPERRES_FILTER_BITS: u8 = 6; // Number of bits of fractional precision for upscaling filter selection
pub const SUPERRES_FILTER_SHIFTS: u8 = 1 << SUPERRES_FILTER_BITS; // Number of phases of upscaling filters
pub const SUPERRES_FILTER_TAPS: u8 = 8; // Number of taps of upscaling filters
pub const SUPERRES_FILTER_OFFSET: u8 = 3; // Sample offset for upscaling filters
pub const SUPERRES_SCALE_BITS: u8 = 14; // Number of fractional bits for computing position in upscaling
pub const SUPERRES_SCALE_MASK: u32 = (1 << 14) - 1; // Mask for computing position in upscaling
pub const SUPERRES_EXTRA_BITS: u8 = 8; // Difference in precision between SUPERRES_SCALE_BITS and SUPERRES_FILTER_BITS
pub const TXB_SKIP_CONTEXTS: u8 = 13; // Number of contexts for all_zero
pub const EOB_COEF_CONTEXTS: u8 = 9; // Number of contexts for eob_extra
pub const DC_SIGN_CONTEXTS: u8 = 3; // Number of contexts for dc_sign
pub const LEVEL_CONTEXTS: u8 = 21; // Number of contexts for coeff_br
pub const TX_CLASS_2D: u8 = 0; // Transform class for transform types performing non-identity transforms in both directions
pub const TX_CLASS_HORIZ: u8 = 1; // Transform class for transforms performing only a horizontal non-identity transform
pub const TX_CLASS_VERT: u8 = 2; // Transform class for transforms performing only a vertical non-identity transform
pub const REFMVS_LIMIT: u32 = (1 << 12) - 1; // Largest reference MV component that can be saved
pub const INTRA_FILTER_SCALE_BITS: u8 = 4; // Scaling shift for intra filtering process
pub const INTRA_FILTER_MODES: u8 = 5; // Number of types of intra filtering
pub const COEFF_CDF_Q_CTXS: u8 = 4; // Number of selectable context types for the coeff( ) syntax structure
pub const PRIMARY_REF_NONE: u8 = 7; // Value of primary_ref_frame indicating that there is no primary reference frame
pub const BUFFER_POOL_MAX_SIZE: u8 = 10; // Number of frames in buffer pool
