pub static REFS_PER_FRAME: u8 = 7; // Number of reference frames that can be used for inter prediction
pub static TOTAL_REFS_PER_FRAME: u8 = 8; // Number of reference frame types (including intra type)
pub static BLOCK_SIZE_GROUPS: u8 = 4; // Number of contexts when decoding y_mode
pub static BLOCK_SIZES: u8 = 22; // Number of different block sizes used
pub static BLOCK_INVALID: u8 = 22; // Sentinel value to mark partition choices that are not allowed
pub static MAX_SB_SIZE: u8 = 128; // Maximum size of a superblock in luma samples
pub static MI_SIZE: u8 = 4; // Smallest size of a mode info block in luma samples
pub static MI_SIZE_LOG2: u8 = 2; // Base 2 logarithm of smallest size of a mode info block
pub static MAX_TILE_WIDTH: u16 = 4096; // Maximum width of a tile in units of luma samples
pub static MAX_TILE_AREA: u32 = 4096 * 2304; // Maximum area of a tile in units of luma samples
pub static MAX_TILE_ROWS: u8 = 64; // Maximum number of tile rows
pub static MAX_TILE_COLS: u8 = 64; // Maximum number of tile columns
pub static INTRABC_DELAY_PIXELS: u16 = 256; // Number of horizontal luma samples before intra block copy can be used
pub static INTRABC_DELAY_SB64: u8 = 4; // Number of 64 by 64 blocks before intra block copy can be used
pub static NUM_REF_FRAMES: u8 = 8; // Number of frames that can be stored for future reference
pub static IS_INTER_CONTEXTS: u8 = 4; // Number of contexts for is_inter
pub static REF_CONTEXTS: u8 = 3; // Number of contexts for single_ref, comp_ref, comp_bwdref, uni_comp_ref,
                                 // uni_comp_ref_p1 and uni_comp_ref_p2
pub static MAX_SEGMENTS: u8 = 8; // Number of segments allowed in segmentation map
pub static SEGMENT_ID_CONTEXTS: u8 = 3; // Number of contexts for segment_id
pub static SEG_LVL_ALT_Q: u8 = 0; // Index for quantizer segment feature
pub static SEG_LVL_ALT_LF_Y_V: u8 = 1; // Index for vertical luma loop filter segment feature
pub static SEG_LVL_REF_FRAME: u8 = 5; // Index for reference frame segment feature
pub static SEG_LVL_SKIP: u8 = 6; // Index for skip segment feature
pub static SEG_LVL_GLOBALMV: u8 = 7; // Index for global mv feature
pub static SEG_LVL_MAX: u8 = 8; // Number of segment features
pub static PLANE_TYPES: u8 = 2; // Number of different plane types (luma or chroma)
pub static TX_SIZE_CONTEXTS: u8 = 3; // Number of contexts for transform size
pub static INTERP_FILTERS: u8 = 3; // Number of values for interp_filter
pub static INTERP_FILTER_CONTEXTS: u8 = 16; // Number of contexts for interp_filter
pub static SKIP_MODE_CONTEXTS: u8 = 3; // Number of contexts for decoding skip_mode
pub static SKIP_CONTEXTS: u8 = 3; // Number of contexts for decoding skip
pub static PARTITION_CONTEXTS: u8 = 4; // Number of contexts when decoding partition
pub static TX_SIZES: u8 = 5; // Number of square transform sizes
pub static TX_SIZES_ALL: u8 = 19; // Number of transform sizes (including non-square sizes)
pub static TX_MODES: u8 = 3; // Number of values for tx_mode
pub static DCT_DCT: u8 = 0; // Inverse transform rows with DCT and columns with DCT
pub static ADST_DCT: u8 = 1; // Inverse transform rows with DCT and columns with ADST
pub static DCT_ADST: u8 = 2; // Inverse transform rows with ADST and columns with DCT
pub static ADST_ADST: u8 = 3; // Inverse transform rows with ADST and columns with ADST
pub static FLIPADST_DCT: u8 = 4; // Inverse transform rows with DCT and columns with FLIPADST
pub static DCT_FLIPADST: u8 = 5; // Inverse transform rows with FLIPADST and columns with DCT
pub static FLIPADST_FLIPADST: u8 = 6; // Inverse transform rows with FLIPADST and columns with FLIPADST
pub static ADST_FLIPADST: u8 = 7; // Inverse transform rows with FLIPADST and columns with ADST
pub static FLIPADST_ADST: u8 = 8; // Inverse transform rows with ADST and columns with FLIPADST
pub static IDTX: u8 = 9; // Inverse transform rows with identity and columns with identity
pub static V_DCT: u8 = 10; // Inverse transform rows with identity and columns with DCT
pub static H_DCT: u8 = 11; // Inverse transform rows with DCT and columns with identity
pub static V_ADST: u8 = 12; // Inverse transform rows with identity and columns with ADST
pub static H_ADST: u8 = 13; // Inverse transform rows with ADST and columns with identity
pub static V_FLIPADST: u8 = 14; // Inverse transform rows with identity and columns with FLIPADST
pub static H_FLIPADST: u8 = 15; // Inverse transform rows with FLIPADST and columns with identity
pub static TX_TYPES: u8 = 16; // Number of inverse transform types
pub static MB_MODE_COUNT: u8 = 17; // Number of values for YMode
pub static INTRA_MODES: u8 = 13; // Number of values for y_mode
pub static UV_INTRA_MODES_CFL_NOT_ALLOWED: u8 = 13; // Number of values for uv_mode when chroma from luma is not allowed
pub static UV_INTRA_MODES_CFL_ALLOWED: u8 = 14; // Number of values for uv_mode when chroma from luma is allowed
pub static COMPOUND_MODES: u8 = 8; // Number of values for compound_mode
pub static COMPOUND_MODE_CONTEXTS: u8 = 8; // Number of contexts for compound_mode
pub static COMP_NEWMV_CTXS: u8 = 5; // Number of new mv values used when constructing context for compound_mode
pub static NEW_MV_CONTEXTS: u8 = 6; // Number of contexts for new_mv
pub static ZERO_MV_CONTEXTS: u8 = 2; // Number of contexts for zero_mv
pub static REF_MV_CONTEXTS: u8 = 6; // Number of contexts for ref_mv
pub static DRL_MODE_CONTEXTS: u8 = 3; // Number of contexts for drl_mode
pub static MV_CONTEXTS: u8 = 2; // Number of contexts for decoding motion vectors including one for intra block
                                // copy
pub static MV_INTRABC_CONTEXT: u8 = 1; // Motion vector context used for intra block copy
pub static MV_JOINTS: u8 = 4; // Number of values for mv_joint
pub static MV_CLASSES: u8 = 11; // Number of values for mv_class
pub static CLASS0_SIZE: u8 = 2; // Number of values for mv_class0_bit
pub static MV_OFFSET_BITS: u8 = 10; // Maximum number of bits for decoding motion vectors
pub static MAX_LOOP_FILTER: u8 = 63; // Maximum value used for loop filtering
pub static REF_SCALE_SHIFT: u8 = 14; // Number of bits of precision when scaling reference frames
pub static SUBPEL_BITS: u8 = 4; // Number of bits of precision when choosing an inter prediction filter kernel
pub static SUBPEL_MASK: u8 = 15; // ( 1 << SUBPEL_BITS ) - 1
pub static SCALE_SUBPEL_BITS: u8 = 10; // Number of bits of precision when computing inter prediction locations
pub static MV_BORDER: u8 = 128; // Value used when clipping motion vectors
pub static PALETTE_COLOR_CONTEXTS: u8 = 5; // Number of values for color contexts
pub static PALETTE_MAX_COLOR_CONTEXT_HASH: u8 = 8; // Number of mappings between color context hash and color context
pub static PALETTE_BLOCK_SIZE_CONTEXTS: u8 = 7; // Number of values for palette block size
pub static PALETTE_Y_MODE_CONTEXTS: u8 = 3; // Number of values for palette Y plane mode contexts
pub static PALETTE_UV_MODE_CONTEXTS: u8 = 2; // Number of values for palette U and V plane mode contexts
pub static PALETTE_SIZES: u8 = 7; // Number of values for palette_size
pub static PALETTE_COLORS: u8 = 8; // Number of values for palette_color
pub static PALETTE_NUM_NEIGHBORS: u8 = 3; // Number of neighbors considered within palette computation
pub static DELTA_Q_SMALL: u8 = 3; // Value indicating alternative encoding of quantizer index delta values
pub static DELTA_LF_SMALL: u8 = 3; // Value indicating alternative encoding of loop filter delta values
pub static QM_TOTAL_SIZE: u16 = 3344; // Number of values in the quantizer matrix
pub static MAX_ANGLE_DELTA: u8 = 3; // Maximum magnitude of AngleDeltaY and AngleDeltaUV
pub static DIRECTIONAL_MODES: u8 = 8; // Number of directional intra modes
pub static ANGLE_STEP: u8 = 3; // Number of degrees of step per unit increase in AngleDeltaY or AngleDeltaUV.
pub static TX_SET_TYPES_INTRA: u8 = 3; // Number of intra transform set types
pub static TX_SET_TYPES_INTER: u8 = 4; // Number of inter transform set types
pub static WARPEDMODEL_PREC_BITS: u8 = 16; // Internal precision of warped motion models
pub static IDENTITY: u8 = 0; // Warp model is just an identity transform
pub static TRANSLATION: u8 = 1; // Warp model is a pure translation
pub static ROTZOOM: u8 = 2; // Warp model is a rotation + symmetric zoom + translation
pub static AFFINE: u8 = 3; // Warp model is a general affine transform
pub static GM_ABS_TRANS_BITS: u8 = 12; // Number of bits encoded for translational components of global motion models,
                                       // if part of a ROTZOOM or AFFINE model
pub static GM_ABS_TRANS_ONLY_BITS: u8 = 9; // Number of bits encoded for translational components of global motion models,
                                           // if part of a TRANSLATION model
pub static GM_ABS_ALPHA_BITS: u8 = 12; // Number of bits encoded for non-translational components of global motion
                                       // models
pub static DIV_LUT_PREC_BITS: u8 = 14; // Number of fractional bits of entries in divisor lookup table
pub static DIV_LUT_BITS: u8 = 8; // Number of fractional bits for lookup in divisor lookup table
pub static DIV_LUT_NUM: u16 = 257; // Number of entries in divisor lookup table
pub static MOTION_MODES: u8 = 3; // Number of values for motion modes
pub static SIMPLE: u8 = 0; // Use translation or global motion compensation
pub static OBMC: u8 = 1; // Use overlapped block motion compensation
pub static LOCALWARP: u8 = 2; // Use local warp motion compensation
pub static LEAST_SQUARES_SAMPLES_MAX: u8 = 8; // Largest number of samples used when computing a local warp
pub static LS_MV_MAX: u16 = 256; // Largest motion vector difference to include in local warp computation
pub static WARPEDMODEL_TRANS_CLAMP: u32 = 1 << 23; // Clamping value used for translation components of warp
pub static WARPEDMODEL_NONDIAGAFFINE_CLAMP: u32 = 1 << 13; // Clamping value used for matrix components of warp
pub static WARPEDPIXEL_PREC_SHIFTS: u8 = 1 << 6; // Number of phases used in warped filtering
pub static WARPEDDIFF_PREC_BITS: u8 = 10; // Number of extra bits of precision in warped filtering
pub static GM_ALPHA_PREC_BITS: u8 = 15; // Number of fractional bits for sending non-translational warp model
                                        // coefficients
pub static GM_TRANS_PREC_BITS: u8 = 6; // Number of fractional bits for sending translational warp model coefficients
pub static GM_TRANS_ONLY_PREC_BITS: u8 = 3; // Number of fractional bits used for pure translational warps
pub static INTERINTRA_MODES: u8 = 4; // Number of inter intra modes
pub static MASK_MASTER_SIZE: u8 = 64; // Size of MasterMask array
pub static SEGMENT_ID_PREDICTED_CONTEXTS: u8 = 3; // Number of contexts for segment_id_predicted
pub static FWD_REFS: u8 = 4; // Number of syntax elements for forward reference frames
pub static BWD_REFS: u8 = 3; // Number of syntax elements for backward reference frames
pub static SINGLE_REFS: u8 = 7; // Number of syntax elements for single reference frames
pub static UNIDIR_COMP_REFS: u8 = 4; // Number of syntax elements for unidirectional compound reference frames
pub static COMPOUND_TYPES: u8 = 2; // Number of values for compound_type
pub static CFL_JOINT_SIGNS: u8 = 8; // Number of values for cfl_alpha_signs
pub static CFL_ALPHABET_SIZE: u8 = 16; // Number of values for cfl_alpha_u and cfl_alpha_v
pub static COMP_INTER_CONTEXTS: u8 = 5; // Number of contexts for comp_mode
pub static COMP_REF_TYPE_CONTEXTS: u8 = 5; // Number of contexts for comp_ref_type
pub static CFL_ALPHA_CONTEXTS: u8 = 6; // Number of contexts for cfl_alpha_u and cfl_alpha_v
pub static INTRA_MODE_CONTEXTS: u8 = 5; // Number of each of left and above contexts for intra_frame_y_mode
pub static COMP_GROUP_IDX_CONTEXTS: u8 = 6; // Number of contexts for comp_group_idx
pub static COMPOUND_IDX_CONTEXTS: u8 = 6; // Number of contexts for compound_idx
pub static INTRA_EDGE_KERNELS: u8 = 3; // Number of filter kernels for the intra edge filter
pub static INTRA_EDGE_TAPS: u8 = 5; // Number of kernel taps for the intra edge filter
pub static FRAME_LF_COUNT: u8 = 4; // Number of loop filter strength values
pub static MAX_VARTX_DEPTH: u8 = 2; // Maximum depth for variable transform trees
pub static TXFM_PARTITION_CONTEXTS: u8 = 21; // Number of contexts for txfm_split
pub static REF_CAT_LEVEL: u16 = 640; // Bonus weight for close motion vectors
pub static MAX_REF_MV_STACK_SIZE: u8 = 8; // Maximum number of motion vectors in the stack
pub static MFMV_STACK_SIZE: u8 = 3; // Stack size for motion field motion vectors
pub static MAX_TX_DEPTH: u8 = 2; // Maximum times the transform can be split
pub static WEDGE_TYPES: u8 = 16; // Number of directions for the wedge mask process
pub static FILTER_BITS: u8 = 7; // Number of bits used in Wiener filter coefficients
pub static WIENER_COEFFS: u8 = 3; // Number of Wiener filter coefficients to read
pub static SGRPROJ_PARAMS_BITS: u8 = 4; // Number of bits needed to specify self guided filter set
pub static SGRPROJ_PRJ_SUBEXP_K: u8 = 4; // Controls how self guided deltas are read
pub static SGRPROJ_PRJ_BITS: u8 = 7; // Precision bits during self guided restoration
pub static SGRPROJ_RST_BITS: u8 = 4; // Restoration precision bits generated higher than source before projection
pub static SGRPROJ_MTABLE_BITS: u8 = 20; // Precision of mtable division table
pub static SGRPROJ_RECIP_BITS: u8 = 12; // Precision of division by n table
pub static SGRPROJ_SGR_BITS: u8 = 8; // Internal precision bits for core selfguided_restoration
pub static EC_PROB_SHIFT: u8 = 6; // Number of bits to reduce CDF precision during arithmetic coding
pub static EC_MIN_PROB: u8 = 4; // Minimum probability assigned to each symbol during arithmetic coding
pub static SELECT_SCREEN_CONTENT_TOOLS: u8 = 2; // Value that indicates the allow_screen_content_tools syntax element is coded
pub static SELECT_INTEGER_MV: u8 = 2; // Value that indicates the force_integer_mv syntax element is coded
pub static RESTORATION_TILESIZE_MAX: u16 = 256; // Maximum size of a loop restoration tile
pub static MAX_FRAME_DISTANCE: u8 = 31; // Maximum distance when computing weighted prediction
pub static MAX_OFFSET_WIDTH: u8 = 8; // Maximum horizontal offset of a projected motion vector
pub static MAX_OFFSET_HEIGHT: u8 = 0; // Maximum vertical offset of a projected motion vector
pub static WARP_PARAM_REDUCE_BITS: u8 = 6; // Rounding bitwidth for the parameters to the shear process
pub static NUM_BASE_LEVELS: u8 = 2; // Number of quantizer base levels
pub static COEFF_BASE_RANGE: u8 = 12; // The quantizer range above NUM_BASE_LEVELS above which the Exp-Golomb coding
                                      // process is activated
pub static BR_CDF_SIZE: u8 = 4; // Number of values for coeff_br
pub static SIG_COEF_CONTEXTS_EOB: u8 = 4; // Number of contexts for coeff_base_eob
pub static SIG_COEF_CONTEXTS_2D: u8 = 26; // Context offset for coeff_base for horizontal-only or vertical-only
                                          // transforms.
pub static SIG_COEF_CONTEXTS: u8 = 42; // Number of contexts for coeff_base
pub static SIG_REF_DIFF_OFFSET_NUM: u8 = 5; // Maximum number of context samples to be used in determining the context index
                                            // for coeff_base and coeff_base_eob.
pub static SUPERRES_NUM: u8 = 8; // Numerator for upscaling ratio
pub static SUPERRES_DENOM_MIN: u8 = 9; // Smallest denominator for upscaling ratio
pub static SUPERRES_DENOM_BITS: u8 = 3; // Number of bits sent to specify denominator of upscaling ratio
pub static SUPERRES_FILTER_BITS: u8 = 6; // Number of bits of fractional precision for upscaling filter selection
pub static SUPERRES_FILTER_SHIFTS: u8 = 1 << SUPERRES_FILTER_BITS; // Number of phases of upscaling filters
pub static SUPERRES_FILTER_TAPS: u8 = 8; // Number of taps of upscaling filters
pub static SUPERRES_FILTER_OFFSET: u8 = 3; // Sample offset for upscaling filters
pub static SUPERRES_SCALE_BITS: u8 = 14; // Number of fractional bits for computing position in upscaling
pub static SUPERRES_SCALE_MASK: u32 = (1 << 14) - 1; // Mask for computing position in upscaling
pub static SUPERRES_EXTRA_BITS: u8 = 8; // Difference in precision between SUPERRES_SCALE_BITS and SUPERRES_FILTER_BITS
pub static TXB_SKIP_CONTEXTS: u8 = 13; // Number of contexts for all_zero
pub static EOB_COEF_CONTEXTS: u8 = 9; // Number of contexts for eob_extra
pub static DC_SIGN_CONTEXTS: u8 = 3; // Number of contexts for dc_sign
pub static LEVEL_CONTEXTS: u8 = 21; // Number of contexts for coeff_br
pub static TX_CLASS_2D: u8 = 0; // Transform class for transform types performing non-identity transforms in
                                // both directions
pub static TX_CLASS_HORIZ: u8 = 1; // Transform class for transforms performing only a horizontal non-identity
                                   // transform
pub static TX_CLASS_VERT: u8 = 2; // Transform class for transforms performing only a vertical non-identity
                                  // transform
pub static REFMVS_LIMIT: u32 = (1 << 12) - 1; // Largest reference MV component that can be saved
pub static INTRA_FILTER_SCALE_BITS: u8 = 4; // Scaling shift for intra filtering process
pub static INTRA_FILTER_MODES: u8 = 5; // Number of types of intra filtering
pub static COEFF_CDF_Q_CTXS: u8 = 4; // Number of selectable context types for the coeff( ) syntax structure
pub static PRIMARY_REF_NONE: u8 = 7; // Value of primary_ref_frame indicating that there is no primary reference
                                     // frame
pub static BUFFER_POOL_MAX_SIZE: u8 = 10; // Number of frames in buffer pool
